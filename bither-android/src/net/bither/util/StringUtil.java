/* * Copyright 2014 http://Bither.net * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *    http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package net.bither.util;import android.annotation.SuppressLint;import android.content.ClipData;import android.content.Context;import net.bither.BitherApplication;import net.bither.bitherj.crypto.DumpedPrivateKey;import net.bither.bitherj.exception.AddressFormatException;import net.bither.bitherj.exception.ScriptException;import net.bither.bitherj.script.Script;import net.bither.bitherj.utils.Base58;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.List;import java.util.Locale;import java.util.regex.Matcher;import java.util.regex.Pattern;public class StringUtil {    public static final String QR_CODE_SPLIT = ":";    private static final String QR_CODE_LETTER = "*";    private static final int MAX_QRCODE_SIZE = 328;    private static final Pattern JSONP_MATCHER = Pattern            .compile(".+\\((.+)\\)");    private static final Pattern PATTERN_BITCOIN_ADDRESS = Pattern.compile("["            + new String(Base58.ALPHABET) + "]{20,40}");    public static boolean checkAddressIsNull(String addressStr) {        byte[] EMPTY_BYTES = new byte[32];        String address;        try {            address = new Script(Script.createInputScript(EMPTY_BYTES,                    EMPTY_BYTES))                    .getToAddress();            return compareString(addressStr, address);        } catch (ScriptException e) {            e.printStackTrace();        }        return false;    }    public static boolean compareString(String str, String other) {        if (str == null) {            if (other == null) {                return true;            } else {                return false;            }        } else {            if (other == null) {                return false;            } else {                return str.equals(other);            }        }    }    public static String formatDoubleToMoneyString(double num) {        java.text.DecimalFormat formate = new DecimalFormat("0.00");        return formate.format(num);    }    public static String format(String format, Object... args) {        return String.format(Locale.US, format, args);    }    public static boolean isEmpty(String str) {        if (str == null || str.equals("")) {            return true;        } else {            return false;        }    }    public static boolean isNubmer(Object obj) {        try {            Double.parseDouble(obj.toString());            return true;        } catch (Exception e) {            return false;        }    }    public static boolean isInteger(Object obj) {        try {            Integer.parseInt(obj.toString());            return true;        } catch (Exception e) {            return false;        }    }    public static boolean isLong(Object obj) {        try {            Long.parseLong(obj.toString());            return true;        } catch (Exception e) {            return false;        }    }    public static String makeFragmentName(int paramInt1, int paramInt2) {        return "android:switcher:" + paramInt1 + ":" + paramInt2;    }    public static boolean validPassword(CharSequence password) {        String pattern = "[0-9,a-z,A-Z]+";        Pattern p = Pattern.compile(pattern);        Matcher m = p.matcher(password);        return m.matches();    }    public static boolean validBitcoinPrivateKey(String str) {        try {            DumpedPrivateKey dumpedPrivateKey = new DumpedPrivateKey(str);            return true;        } catch (AddressFormatException e) {            e.printStackTrace();        }        return false;    }    public static boolean validBicoinAddress(String str) {        if (PATTERN_BITCOIN_ADDRESS.matcher(str).matches()) {            try {                Base58.decodeChecked(str);                return true;            } catch (final AddressFormatException x) {                x.printStackTrace();            }        }        return false;    }    @SuppressLint("NewApi")    public static void copyString(String text) {        if (android.os.Build.VERSION.SDK_INT > 10) {            android.content.ClipboardManager clip = (android.content.ClipboardManager)                    BitherApplication.mContext                            .getSystemService(Context.CLIPBOARD_SERVICE);            clip.setPrimaryClip(ClipData.newPlainText(text, text));        } else {            android.text.ClipboardManager clipM = (android.text.ClipboardManager)                    BitherApplication.mContext                            .getSystemService(Context.CLIPBOARD_SERVICE);            clipM.setText(text);        }    }    public static byte[] hexStringToByteArray(String s) {        int len = s.length();        byte[] data = new byte[len / 2];        for (int i = 0;             i < len;             i += 2) {            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character                    .digit(s.charAt(i + 1), 16));        }        return data;    }    public static String encodeQrCodeString(String text) {        Pattern pattern = Pattern.compile("[A-Z]");        Matcher matcher = pattern.matcher(text);        StringBuffer sb = new StringBuffer();        while (matcher.find()) {            String letter = matcher.group(0);            matcher.appendReplacement(sb, QR_CODE_LETTER + letter);        }        matcher.appendTail(sb);        return sb.toString().toUpperCase(Locale.US);    }    public static String decodeQrCodeString(String formatString) {        formatString = formatString.toLowerCase(Locale.US);        Pattern pattern = Pattern.compile("\\*([a-z])");        Matcher matcher = pattern.matcher(formatString);        StringBuffer sb = new StringBuffer();        while (matcher.find()) {            String letter = matcher.group(1);            matcher.appendReplacement(sb, letter.toUpperCase(Locale.US));        }        matcher.appendTail(sb);        return sb.toString();    }    public static boolean verifyQrcodeTransport(String text) {        Pattern pattern = Pattern.compile("[^0-9A-Z\\*:]");        Matcher matcher = pattern.matcher(text);        if (matcher.find()) {            return false;        }        return true;    }    public static List<String> getQrCodeStringList(String str) {        List<String> stringList = new ArrayList<String>();        int num = getNumOfQrCodeString(str.length());        int sumLength = str.length() + num * 6;        int pageSize = sumLength / num;        for (int i = 0;             i < num;             i++) {            int start = i * pageSize;            int end = (i + 1) * pageSize;            LogUtil.d("qr", "s:" + start + " e:" + end);            if (start > str.length() - 1) {                continue;            }            if (end > str.length()) {                end = str.length();            }            String splitStr = str.substring(start, end);            String pageString = "";            if (num > 1) {                pageString = Integer.toString(num - 1) + QR_CODE_SPLIT                        + Integer.toString(i) + QR_CODE_SPLIT;            }            stringList.add(pageString + splitStr);        }        return stringList;    }    private static int getNumOfQrCodeString(int length) {        if (length < MAX_QRCODE_SIZE) {            return 1;        } else if (length <= (MAX_QRCODE_SIZE - 4) * 10) {            return length / (MAX_QRCODE_SIZE - 4) + 1;        } else if (length <= (MAX_QRCODE_SIZE - 5) * 100) {            return length / (MAX_QRCODE_SIZE - 5) + 1;        } else if (length <= (MAX_QRCODE_SIZE - 6) * 1000) {            return length / (MAX_QRCODE_SIZE - 6) + 1;        } else {            return 1000;        }    }    public static boolean checkBackupFileOfCold(String fileName) {        Pattern pattern = Pattern.compile("[^-]{6,6}_[^-]{6,6}.bak");        Matcher matcher = pattern.matcher(fileName);        if (matcher.find()) {            return true;        }        return false;    }}