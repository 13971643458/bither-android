/* * Copyright 2014 http://Bither.net * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *    http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package net.bither.util;import android.annotation.SuppressLint;import android.content.ClipData;import android.content.Context;import android.graphics.Typeface;import android.text.Spannable;import android.text.SpannableString;import android.text.style.RelativeSizeSpan;import android.text.style.StyleSpan;import net.bither.BitherApplication;import net.bither.bitherj.exception.ScriptException;import net.bither.bitherj.script.Script;import net.bither.bitherj.utils.GenericUtils;import net.bither.bitherj.utils.Utils;import java.text.DecimalFormat;import java.util.Locale;import java.util.regex.Matcher;import java.util.regex.Pattern;public class StringUtil {    public static SpannableString formatValueWithBold(final long value) {        return formatValueWithBold(value, 2);    }    private static SpannableString formatValueWithBold(final long value, int boldLengthAfterDot) {        String str = GenericUtils.formatValue(value);        int dotPosition = str.indexOf(".");        int boldLength = str.length();        if (dotPosition > 0 && dotPosition + boldLengthAfterDot < str.length()) {            boldLength = dotPosition + boldLengthAfterDot + 1;        }        SpannableString spannable = new SpannableString(str);        spannable.setSpan(new StyleSpan(Typeface.BOLD), 0, boldLength,                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);        if (boldLength < str.length()) {            spannable.setSpan(new RelativeSizeSpan(0.8f), boldLength, str.length(),                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);        }        return spannable;    }    public static boolean checkAddressIsNull(String addressStr) {        byte[] EMPTY_BYTES = new byte[32];        String address;        try {            address = new Script(Script.createInputScript(EMPTY_BYTES,                    EMPTY_BYTES))                    .getToAddress();            return Utils.compareString(addressStr, address);        } catch (ScriptException e) {            e.printStackTrace();        }        return false;    }    public static String format(String format, Object... args) {        return String.format(Locale.US, format, args);    }    public static String makeFragmentName(int paramInt1, int paramInt2) {        return "android:switcher:" + paramInt1 + ":" + paramInt2;    }    @SuppressLint("NewApi")    public static void copyString(String text) {        if (android.os.Build.VERSION.SDK_INT > 10) {            android.content.ClipboardManager clip = (android.content.ClipboardManager)                    BitherApplication.mContext                            .getSystemService(Context.CLIPBOARD_SERVICE);            clip.setPrimaryClip(ClipData.newPlainText(text, text));        } else {            android.text.ClipboardManager clipM = (android.text.ClipboardManager)                    BitherApplication.mContext                            .getSystemService(Context.CLIPBOARD_SERVICE);            clipM.setText(text);        }    }    public static byte[] hexStringToByteArray(String s) {        int len = s.length();        byte[] data = new byte[len / 2];        for (int i = 0;             i < len;             i += 2) {            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character                    .digit(s.charAt(i + 1), 16));        }        return data;    }    public static boolean checkBackupFileOfCold(String fileName) {        Pattern pattern = Pattern.compile("[^-]{6,6}_[^-]{6,6}.bak");        Matcher matcher = pattern.matcher(fileName);        if (matcher.find()) {            return true;        }        return false;    }}